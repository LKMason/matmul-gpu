!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).matmul={})}(this,(function(e){"use strict";let r=null;async function t(){try{"gpu"in navigator||console.warn("WebGPU not supported. CPU computation will be performed instead.");const e=await navigator.gpu.requestAdapter();return r=await e.requestDevice(),r}catch(e){return console.error(e),console.warn("A problem occured setting up interface with GPU device. CPU computation will be performed instead."),null}}async function n(e,r,n,a,i=!1){const s=n[0][1]-n[0][0],u=n[1][1]-n[1][0],l=a[0][1]-a[0][0],f=a[1][1]-a[1][0];if(i)return o(e,r,n,a);const c=await t();if(!c)return console.warn("No GPU device available. Falling back to CPU multiplication."),o(e,r,n,a);try{const t=new Float32Array(s*u);let o=0;for(let r=n[0][0];r<n[0][1];r++)for(let a=n[1][0];a<n[1][1];a++)t[o++]=e[r][a];const i=new Float32Array(l*f);o=0;for(let e=a[0][0];e<a[0][1];e++)for(let t=a[1][0];t<a[1][1];t++)i[o++]=r[e][t];const g=c.createBuffer({size:t.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),d=c.createBuffer({size:i.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),p=s,m=f,h=4*p*m,b=c.createBuffer({size:h,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),y=c.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});c.queue.writeBuffer(g,0,t),c.queue.writeBuffer(d,0,i);const U=new Uint32Array([s,u,f,0]);c.queue.writeBuffer(y,0,U);const w="\n       @group(0) @binding(0) var<storage, read> A : array<f32>;\n       @group(0) @binding(1) var<storage, read> B : array<f32>;\n       @group(0) @binding(2) var<storage, read_write> C : array<f32>;\n       @group(0) @binding(3) var<uniform> dims : vec4<u32>;\n       // dims.x = slicedARows, dims.y = slicedACols, dims.z = slicedBCols\n\n       @compute @workgroup_size(16, 16)\n       fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n         let aRows = dims.x;\n         let aCols = dims.y;\n         let bCols = dims.z;\n\n         let row = gid.y;\n         let col = gid.x;\n\n         if (row < aRows && col < bCols) {\n           var sum = 0.0;\n           for (var k = 0u; k < aCols; k++) {\n             sum += A[row * aCols + k] * B[k * bCols + col];\n           }\n           C[row * bCols + col] = sum;\n         }\n       }\n     ",P=c.createShaderModule({code:w}),B=c.createComputePipeline({layout:"auto",compute:{module:P,entryPoint:"main"}}),C=c.createBindGroup({layout:B.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g}},{binding:1,resource:{buffer:d}},{binding:2,resource:{buffer:b}},{binding:3,resource:{buffer:y}}]}),A=c.createCommandEncoder(),G=A.beginComputePass();G.setPipeline(B),G.setBindGroup(0,C);const M=16,v=Math.ceil(m/M),T=Math.ceil(p/M);G.dispatchWorkgroups(v,T),G.end();const R=c.createBuffer({size:h,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});A.copyBufferToBuffer(b,0,R,0,h),c.queue.submit([A.finish()]),await R.mapAsync(GPUMapMode.READ);const S=R.getMappedRange(),_=new Float32Array(S.slice(0));R.unmap();const z=[];let O=0;for(let e=0;e<p;e++){const e=[];for(let r=0;r<m;r++)e.push(_[O++]);z.push(e)}return z}catch(t){return console.error("WebGPU error:",t,"Falling back to CPU multiplication."),o(e,r,n,a)}}function o(e,r,t,n){const[o,a]=t[0],[i,s]=t[1],[u,l]=n[0],[f,c]=n[1],g=s-i,d=a-o,p=c-f,m=Array(d).fill(null).map((()=>Array(p).fill(0)));for(let t=0;t<d;t++)for(let n=0;n<p;n++)for(let a=0;a<g;a++)m[t][n]+=e[o+t][i+a]*r[u+a][f+n];return m}e.isGpuAvailable=async function(){return null!=await t()},e.matrixMultiply=async function(e,r,t={}){let{batchSize:o=1024,operationsGpuThreshold:a=373248}=t;const i=e.length,s=e[0].length,u=r.length,l=r[0].length;if(s!==u)throw new Error("Inner dimensions of matrices must match for multiplication");if(null==o&&(o=[Math.max(i,s,l),Math.max(i,s,l)]),Array.isArray(o)||(o=[o,o]),o[0]<2||o[1]<2)throw new Error("Batch size must be >1");let f=!1;i*s*l<a&&(f=!0);const c=Array.from({length:i},(()=>Array(l).fill(0))),g=Math.ceil(i/o[0]),d=Math.ceil(s/o[1]),p=Math.ceil(l/o[1]);for(let t=0;t<g;t++)for(let a=0;a<p;a++)for(let u=0;u<d;u++){const g=t*o[0],d=Math.min((t+1)*o[0],i),p=u*o[1],m=Math.min((u+1)*o[1],s),h=u*o[1],b=Math.min((u+1)*o[1],s),y=a*o[1],U=Math.min((a+1)*o[1],l),w=await n(e,r,[[g,d],[p,m]],[[h,b],[y,U]],f);for(let e=0;e<w.length;e++)for(let r=0;r<w[0].length;r++)c[g+e][y+r]+=w[e][r]}return c}}));
//# sourceMappingURL=matmul-gpu.umd.min.js.map
