!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).matmul={})}(this,(function(e){"use strict";async function r(e,r,n,o){const a=n[0][1]-n[0][0],i=n[1][1]-n[1][0],s=o[0][1]-o[0][0],u=o[1][1]-o[1][0];if(!("gpu"in navigator))return console.error("WebGPU not supported. Falling back to CPU multiplication."),t(e,r,n,o);try{const t=await navigator.gpu.requestAdapter(),f=await t.requestDevice(),l=new Float32Array(a*i);let c=0;for(let r=n[0][0];r<n[0][1];r++)for(let t=n[1][0];t<n[1][1];t++)l[c++]=e[r][t];const g=new Float32Array(s*u);c=0;for(let e=o[0][0];e<o[0][1];e++)for(let t=o[1][0];t<o[1][1];t++)g[c++]=r[e][t];const d=f.createBuffer({size:l.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),m=f.createBuffer({size:g.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),p=a,h=u,b=4*p*h,y=f.createBuffer({size:b,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),U=f.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});f.queue.writeBuffer(d,0,l),f.queue.writeBuffer(m,0,g);const B=new Uint32Array([a,i,u,0]);f.queue.writeBuffer(U,0,B);const P="\n       @group(0) @binding(0) var<storage, read> A : array<f32>;\n       @group(0) @binding(1) var<storage, read> B : array<f32>;\n       @group(0) @binding(2) var<storage, read_write> C : array<f32>;\n       @group(0) @binding(3) var<uniform> dims : vec4<u32>;\n       // dims.x = slicedARows, dims.y = slicedACols, dims.z = slicedBCols\n\n       @compute @workgroup_size(16, 16)\n       fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n         let aRows = dims.x;\n         let aCols = dims.y;\n         let bCols = dims.z;\n\n         let row = gid.y;\n         let col = gid.x;\n\n         if (row < aRows && col < bCols) {\n           var sum = 0.0;\n           for (var k = 0u; k < aCols; k++) {\n             sum += A[row * aCols + k] * B[k * bCols + col];\n           }\n           C[row * bCols + col] = sum;\n         }\n       }\n     ",w=f.createShaderModule({code:P}),C=f.createComputePipeline({layout:"auto",compute:{module:w,entryPoint:"main"}}),A=f.createBindGroup({layout:C.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:m}},{binding:2,resource:{buffer:y}},{binding:3,resource:{buffer:U}}]}),G=f.createCommandEncoder(),M=G.beginComputePass();M.setPipeline(C),M.setBindGroup(0,A);const v=16,R=Math.ceil(h/v),T=Math.ceil(p/v);M.dispatchWorkgroups(R,T),M.end();const _=f.createBuffer({size:b,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});G.copyBufferToBuffer(y,0,_,0,b),f.queue.submit([G.finish()]),await _.mapAsync(GPUMapMode.READ);const O=_.getMappedRange(),S=new Float32Array(O.slice(0));_.unmap();const k=[];let z=0;for(let e=0;e<p;e++){const e=[];for(let r=0;r<h;r++)e.push(S[z++]);k.push(e)}return k}catch(a){return console.error("WebGPU error:",a,"Falling back to CPU multiplication."),t(e,r,n,o)}}function t(e,r,t,n){const[o,a]=t[0],[i,s]=t[1],[u,f]=n[0],[l,c]=n[1],g=s-i,d=a-o,m=c-l,p=Array(d).fill(null).map((()=>Array(m).fill(0)));for(let t=0;t<d;t++)for(let n=0;n<m;n++)for(let a=0;a<g;a++)p[t][n]+=e[o+t][i+a]*r[u+a][l+n];return p}e.matrixMultiply=async function(e,t,n=1024){const o=e.length,a=e[0].length,i=t.length,s=t[0].length;if(a!==i)throw new Error("Inner dimensions of matrices must match for multiplication");if(null==n&&(n=Math.max(o,a,s)),n<2)throw new Error("Batch size must be >1");const u=Array.from({length:o},(()=>Array(s).fill(0))),f=Math.ceil(o/n),l=Math.ceil(a/n),c=Math.ceil(s/n);for(let i=0;i<f;i++)for(let f=0;f<c;f++)for(let c=0;c<l;c++){const l=i*n,g=Math.min((i+1)*n,o),d=c*n,m=Math.min((c+1)*n,a),p=c*n,h=Math.min((c+1)*n,a),b=f*n,y=Math.min((f+1)*n,s),U=await r(e,t,[[l,g],[d,m]],[[p,h],[b,y]]);for(let e=0;e<U.length;e++)for(let r=0;r<U[0].length;r++)u[l+e][b+r]+=U[e][r]}return u}}));
//# sourceMappingURL=matmul-gpu.umd.min.js.map
