!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).matmul={})}(this,function(e){"use strict";let r=null;async function t(){try{"gpu"in navigator||console.warn("WebGPU not supported. CPU computation will be performed instead.");const e=await navigator.gpu.requestAdapter();return r=await e.requestDevice(),r}catch(e){return console.error(e),console.warn("A problem occured setting up interface with GPU device. CPU computation will be performed instead."),null}}async function*n(e,r,t={}){let{batchSize:n=1024,operationsGpuThreshold:a=373248}=t;const i=e.length,l=e[0].length,s=r.length,u=r[0].length;if(l!==s)throw new Error("Inner dimensions of matrices must match for multiplication");if(null==n&&(n=[Math.max(i,l,u),Math.max(i,l,u)]),Array.isArray(n)||(n=[n,n]),n[0]<2||n[1]<2)throw new Error("Batch size must be >1");let f=!1;i*l*u<a&&(f=!0);const c=Array.from({length:i},()=>Array(u).fill(0)),d=Math.ceil(i/n[0]),g=Math.ceil(l/n[1]),p=Math.ceil(u/n[1]),m=d*p*g;let y=0;for(let t=0;t<d;t++)for(let a=0;a<p;a++)for(let s=0;s<g;s++){const d=t*n[0],g=Math.min((t+1)*n[0],i),p=s*n[1],h=Math.min((s+1)*n[1],l),b=s*n[1],w=Math.min((s+1)*n[1],l),U=a*n[1],P=Math.min((a+1)*n[1],u),B=await o(e,r,[[d,g],[p,h]],[[b,w],[U,P]],f);for(let e=0;e<B.length;e++)for(let r=0;r<B[0].length;r++)c[d+e][U+r]+=B[e][r];y++,yield{progress:y/m}}yield c}async function o(e,r,n,o,i=!1){const l=n[0][1]-n[0][0],s=n[1][1]-n[1][0],u=o[0][1]-o[0][0],f=o[1][1]-o[1][0];if(i)return a(e,r,n,o);const c=await t();if(!c)return console.warn("No GPU device available. Falling back to CPU multiplication."),a(e,r,n,o);try{const t=new Float32Array(l*s);let a=0;for(let r=n[0][0];r<n[0][1];r++)for(let o=n[1][0];o<n[1][1];o++)t[a++]=e[r][o];const i=new Float32Array(u*f);a=0;for(let e=o[0][0];e<o[0][1];e++)for(let t=o[1][0];t<o[1][1];t++)i[a++]=r[e][t];const d=c.createBuffer({size:t.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),g=c.createBuffer({size:i.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),p=l,m=f,y=4*p*m,h=c.createBuffer({size:y,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),b=c.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});c.queue.writeBuffer(d,0,t),c.queue.writeBuffer(g,0,i);const w=new Uint32Array([l,s,f,0]);c.queue.writeBuffer(b,0,w);const U="\n       @group(0) @binding(0) var<storage, read> A : array<f32>;\n       @group(0) @binding(1) var<storage, read> B : array<f32>;\n       @group(0) @binding(2) var<storage, read_write> C : array<f32>;\n       @group(0) @binding(3) var<uniform> dims : vec4<u32>;\n       // dims.x = slicedARows, dims.y = slicedACols, dims.z = slicedBCols\n\n       @compute @workgroup_size(16, 16)\n       fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n         let aRows = dims.x;\n         let aCols = dims.y;\n         let bCols = dims.z;\n\n         let row = gid.y;\n         let col = gid.x;\n\n         if (row < aRows && col < bCols) {\n           var sum = 0.0;\n           for (var k = 0u; k < aCols; k++) {\n             sum += A[row * aCols + k] * B[k * bCols + col];\n           }\n           C[row * bCols + col] = sum;\n         }\n       }\n     ",P=c.createShaderModule({code:U}),B=c.createComputePipeline({layout:"auto",compute:{module:P,entryPoint:"main"}}),C=c.createBindGroup({layout:B.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:g}},{binding:2,resource:{buffer:h}},{binding:3,resource:{buffer:b}}]}),A=c.createCommandEncoder(),G=A.beginComputePass();G.setPipeline(B),G.setBindGroup(0,C);const M=16,v=Math.ceil(m/M),x=Math.ceil(p/M);G.dispatchWorkgroups(v,x),G.end();const T=c.createBuffer({size:y,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});A.copyBufferToBuffer(h,0,T,0,y),c.queue.submit([A.finish()]),await T.mapAsync(GPUMapMode.READ);const R=T.getMappedRange(),S=new Float32Array(R.slice(0));T.unmap();const _=[];let z=0;for(let e=0;e<p;e++){const e=[];for(let r=0;r<m;r++)e.push(S[z++]);_.push(e)}return _}catch(t){return console.error("WebGPU error:",t,"Falling back to CPU multiplication."),a(e,r,n,o)}}function a(e,r,t,n){const[o,a]=t[0],[i,l]=t[1],[s,u]=n[0],[f,c]=n[1],d=l-i,g=a-o,p=c-f,m=Array(g).fill(null).map(()=>Array(p).fill(0));for(let t=0;t<g;t++)for(let n=0;n<p;n++)for(let a=0;a<d;a++)m[t][n]+=e[o+t][i+a]*r[s+a][f+n];return m}e.isGpuAvailable=async function(){return null!=await t()},e.matrixMultiply=async function(e,r,t={}){const o=n(e,r,t);let a=await o.next(),i=null;for(;!a.done;)i=a.value,a=await o.next();return i},e.matrixMultiplyProgress=n});
//# sourceMappingURL=matmul-gpu.umd.min.js.map
