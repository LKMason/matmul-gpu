{"version":3,"file":"matmul-gpu.umd.min.js","sources":["../src/index.js"],"sourcesContent":["\nlet gpuDevice = null;\n\nasync function getGpuDevice() {\n  try {\n    if (!( \"gpu\" in navigator)) {\n      console.warn(\"WebGPU not supported. CPU computation will be performed instead.\")\n    }\n    const adapter = await navigator.gpu.requestAdapter();\n    gpuDevice = await adapter.requestDevice();\n    return gpuDevice;\n  } catch (e) {\n    console.error(e);\n    console.warn(\"A problem occured setting up interface with GPU device. CPU computation will be performed instead.\");\n    return null;\n  }\n}\n\nexport async function isGpuAvailable() {\n  return await getGpuDevice() != null;\n}\n\n/**\n * Multiplies two 2D matrices, optionally using batched processing.\n * Uses WebGPU if available; otherwise falls back on a JS implementation.\n *\n * @async\n * @function matrixMultiply2D\n * @param {number[][]} matrix1 The first matrix (N x M).\n * @param {number[][]} matrix2 The second matrix (M x K).\n * @param {object} [options={}] An object containing optional parameters.\n * @param {number | number[]} [options.batchSize=1024] The size of the batches to use for processing.  If a single number is provided, it's used as both the row and column batch size. If an array of two numbers is provided, the first number is the row batch size and second is the column batch size. If null, uses the maximum dimension of the matrices, effectively no batching.  Must be greater than 1 if specified.\n * @param {number} [options.operationsGpuThreshold=373248] Number of operations (N x M x K) above which the GPU is used.\n * @returns {number[][]} The resulting matrix (N x K).\n * @throws {Error} If the inner dimensions of the matrices do not match.\n * @throws {Error} If the batch size is less than 2.\n */\nexport async function matrixMultiply(matrix1, matrix2, options={}) {\n  let { \n    batchSize = 1024, \n    operationsGpuThreshold = 373248, // 72 x 72 x 72\n  } = options;\n\n  const N = matrix1.length;\n  const M = matrix1[0].length;\n  const M2 = matrix2.length;\n  const K = matrix2[0].length;\n\n  if (M !== M2) {\n    throw new Error(\"Inner dimensions of matrices must match for multiplication\");\n  }\n\n  if (batchSize == null) {\n    batchSize = [Math.max(N, M, K), Math.max(N, M, K)];\n  }\n\n  if (!Array.isArray(batchSize)) {\n    batchSize = [batchSize, batchSize];\n  }\n\n  if (batchSize[0] < 2 || batchSize[1] < 2) {\n    throw new Error(\"Batch size must be >1\");\n  }\n\n  let forceCpu = false;\n  if (N * M * K < operationsGpuThreshold) {\n    forceCpu = true;\n  }\n\n  // Initialize the result matrix with zeros.\n  const result = Array.from({ length: N }, () => Array(K).fill(0));\n\n  const numRowBlocks1 = Math.ceil(N / batchSize[0]);\n  const numColBlocks1 = Math.ceil(M / batchSize[1]);\n  const numColBlocks2 = Math.ceil(K / batchSize[1]);\n\n  for (let i = 0; i < numRowBlocks1; i++) {\n    for (let j = 0; j < numColBlocks2; j++) {\n      for (let k = 0; k < numColBlocks1; k++) {\n        \n        // Calculate block indices (start and end rows/cols)\n        const rowStart1 = i * batchSize[0];\n        const rowEnd1 = Math.min((i + 1) * batchSize[0], N);\n        const colStart1 = k * batchSize[1];\n        const colEnd1 = Math.min((k + 1) * batchSize[1], M);\n\n        const rowStart2 = k * batchSize[1];\n        const rowEnd2 = Math.min((k + 1) * batchSize[1], M);\n        const colStart2 = j * batchSize[1];\n        const colEnd2 = Math.min((j + 1) * batchSize[1], K);\n          \n        // Multiply and accumulate\n        const product =  await _matrixMultiplySlice(matrix1, matrix2, \n          [[rowStart1, rowEnd1],[colStart1, colEnd1]],[[rowStart2, rowEnd2],[colStart2, colEnd2]], forceCpu);\n\n        for (let pRow = 0; pRow < product.length; pRow++) {\n          for (let pCol = 0; pCol < product[0].length; pCol++) {\n            result[rowStart1 + pRow][colStart2 + pCol] += product[pRow][pCol];\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nasync function _matrixMultiplySlice(A, B, aSlice, bSlice, forceCpu = false) {\n const slicedARows = aSlice[0][1] - aSlice[0][0];\n const slicedACols = aSlice[1][1] - aSlice[1][0];\n const slicedBRows = bSlice[0][1] - bSlice[0][0];\n const slicedBCols = bSlice[1][1] - bSlice[1][0];\n\n if (forceCpu) {\n  return _cpuMatrixMultiply(A, B, aSlice, bSlice);\n} \n\nconst gpuDevice = await getGpuDevice();\nif (!gpuDevice) {\n  console.warn(\"No GPU device available. Falling back to CPU multiplication.\");\n  return _cpuMatrixMultiply(A, B, aSlice, bSlice);\n}\n\n\n // Try GPU multiplication in a try/catch\n try {\n   // Flatten A, using the slice\n   const Adata = new Float32Array(slicedARows * slicedACols);\n   let idx = 0;\n   for (let i = aSlice[0][0]; i < aSlice[0][1]; i++) {\n     for (let j = aSlice[1][0]; j < aSlice[1][1]; j++) {\n       Adata[idx++] = A[i][j];\n     }\n   }\n\n   // Flatten B, using the slice\n   const Bdata = new Float32Array(slicedBRows * slicedBCols);\n   idx = 0;\n   for (let i = bSlice[0][0]; i < bSlice[0][1]; i++) {\n     for (let j = bSlice[1][0]; j < bSlice[1][1]; j++) {\n       Bdata[idx++] = B[i][j];\n     }\n   }\n\n   // Prepare buffers\n   const bufferA = gpuDevice.createBuffer({\n     size: Adata.byteLength,\n     usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n   });\n   const bufferB = gpuDevice.createBuffer({\n     size: Bdata.byteLength,\n     usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n   });\n\n   const cRows = slicedARows;\n   const cCols = slicedBCols;\n   const cSizeBytes = 4 * cRows * cCols;\n\n   const bufferC = gpuDevice.createBuffer({\n     size: cSizeBytes,\n     usage:\n       GPUBufferUsage.STORAGE |\n       GPUBufferUsage.COPY_SRC |\n       GPUBufferUsage.COPY_DST\n   });\n\n   // Uniform buffer {slicedARows, slicedACols, slicedBCols, 0}\n   const uniformBuffer = gpuDevice.createBuffer({\n     size: 16, // 4 x 4 bytes\n     usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n   });\n\n   // Upload data\n   gpuDevice.queue.writeBuffer(bufferA, 0, Adata);\n   gpuDevice.queue.writeBuffer(bufferB, 0, Bdata);\n   const dims = new Uint32Array([slicedARows, slicedACols, slicedBCols, 0]);\n   gpuDevice.queue.writeBuffer(uniformBuffer, 0, dims);\n\n   // WGSL shader\n   const shaderCode = /* wgsl */ `\n       @group(0) @binding(0) var<storage, read> A : array<f32>;\n       @group(0) @binding(1) var<storage, read> B : array<f32>;\n       @group(0) @binding(2) var<storage, read_write> C : array<f32>;\n       @group(0) @binding(3) var<uniform> dims : vec4<u32>;\n       // dims.x = slicedARows, dims.y = slicedACols, dims.z = slicedBCols\n\n       @compute @workgroup_size(16, 16)\n       fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n         let aRows = dims.x;\n         let aCols = dims.y;\n         let bCols = dims.z;\n\n         let row = gid.y;\n         let col = gid.x;\n\n         if (row < aRows && col < bCols) {\n           var sum = 0.0;\n           for (var k = 0u; k < aCols; k++) {\n             sum += A[row * aCols + k] * B[k * bCols + col];\n           }\n           C[row * bCols + col] = sum;\n         }\n       }\n     `;\n   const shaderModule = gpuDevice.createShaderModule({ code: shaderCode });\n\n   // Pipeline\n   const pipeline = gpuDevice.createComputePipeline({\n     layout: \"auto\",\n     compute: {\n       module: shaderModule,\n       entryPoint: \"main\"\n     }\n   });\n\n   // Bind group\n   const bindGroup = gpuDevice.createBindGroup({\n     layout: pipeline.getBindGroupLayout(0),\n     entries: [\n       { binding: 0, resource: { buffer: bufferA } },\n       { binding: 1, resource: { buffer: bufferB } },\n       { binding: 2, resource: { buffer: bufferC } },\n       { binding: 3, resource: { buffer: uniformBuffer } }\n     ]\n   });\n\n   // Encode commands\n   const commandEncoder = gpuDevice.createCommandEncoder();\n   const passEncoder = commandEncoder.beginComputePass();\n   passEncoder.setPipeline(pipeline);\n   passEncoder.setBindGroup(0, bindGroup);\n\n   // Dispatch\n   const workgroupSize = 16;\n   const dispatchX = Math.ceil(cCols / workgroupSize);\n   const dispatchY = Math.ceil(cRows / workgroupSize);\n   passEncoder.dispatchWorkgroups(dispatchX, dispatchY);\n   passEncoder.end();\n\n   // Copy back to a CPU-readable buffer\n   const readBuffer = gpuDevice.createBuffer({\n     size: cSizeBytes,\n     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n   });\n   commandEncoder.copyBufferToBuffer(bufferC, 0, readBuffer, 0, cSizeBytes);\n\n   // Submit\n   gpuDevice.queue.submit([commandEncoder.finish()]);\n   await readBuffer.mapAsync(GPUMapMode.READ);\n   const arrBuffer = readBuffer.getMappedRange();\n   const result = new Float32Array(arrBuffer.slice(0));\n   readBuffer.unmap();\n\n   // Convert to 2D\n   const C = [];\n   let pos = 0;\n   for (let i = 0; i < cRows; i++) {\n     const rowData = [];\n     for (let j = 0; j < cCols; j++) {\n       rowData.push(result[pos++]);\n     }\n     C.push(rowData);\n   }\n\n   return C;\n } catch (err) {\n   console.error(\"WebGPU error:\", err, \"Falling back to CPU multiplication.\");\n   // If anything fails on GPU side, fallback:\n   return _cpuMatrixMultiply(A, B, aSlice, bSlice);\n }\n}\n\nfunction _cpuMatrixMultiply(A, B, aSlice, bSlice) {\n  const [aRowStart, aRowEnd] = aSlice[0];\n  const [aColStart, aColEnd] = aSlice[1];\n  const [bRowStart, _] = bSlice[0];\n  const [bColStart, bColEnd] = bSlice[1];\n\n  const aCols = aColEnd - aColStart;\n\n  const resultRows = aRowEnd - aRowStart;\n  const resultCols = bColEnd - bColStart;\n  const C = Array(resultRows).fill(null).map(() => Array(resultCols).fill(0));\n\n  for (let i = 0; i < resultRows; i++) {\n    for (let j = 0; j < resultCols; j++) {\n      for (let k = 0; k < aCols; k++) {\n        C[i][j] += A[aRowStart + i][aColStart + k] * B[bRowStart + k][bColStart + j];\n      }\n    }\n  }\n\n  return C;\n}"],"names":["gpuDevice","async","getGpuDevice","navigator","console","warn","adapter","gpu","requestAdapter","requestDevice","e","error","_matrixMultiplySlice","A","B","aSlice","bSlice","forceCpu","slicedARows","slicedACols","slicedBRows","slicedBCols","_cpuMatrixMultiply","Adata","Float32Array","idx","i","j","Bdata","bufferA","createBuffer","size","byteLength","usage","GPUBufferUsage","STORAGE","COPY_DST","bufferB","cRows","cCols","cSizeBytes","bufferC","COPY_SRC","uniformBuffer","UNIFORM","queue","writeBuffer","dims","Uint32Array","shaderCode","shaderModule","createShaderModule","code","pipeline","createComputePipeline","layout","compute","module","entryPoint","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","workgroupSize","dispatchX","Math","ceil","dispatchY","dispatchWorkgroups","end","readBuffer","MAP_READ","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","arrBuffer","getMappedRange","result","slice","unmap","C","pos","rowData","push","err","aRowStart","aRowEnd","aColStart","aColEnd","bRowStart","_","bColStart","bColEnd","aCols","resultRows","resultCols","Array","fill","map","k","matrix1","matrix2","options","batchSize","operationsGpuThreshold","N","length","M","M2","K","Error","max","isArray","from","numRowBlocks1","numColBlocks1","numColBlocks2","rowStart1","rowEnd1","min","colStart1","colEnd1","rowStart2","rowEnd2","colStart2","colEnd2","product","pRow","pCol"],"mappings":"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"}