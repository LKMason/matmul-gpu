{"version":3,"file":"matmul-gpu.umd.min.js","sources":["../src/index.js"],"sourcesContent":["\n/**\n * Multiplies two 2D matrices, optionally using batched processing.\n * Uses WebGPU if available; otherwise falls back on a JS implementation.\n *\n * @async\n * @function matrixMultiply2D\n * @param {number[][]} matrix1 The first matrix (N x M).\n * @param {number[][]} matrix2 The second matrix (M x K).\n * @param {number} [batchSize=null] The size of the batches to use for processing.  If null (default),\n *  a batch size is chosen to be the maximum dimension of the input matrices, effectively resulting\n *  in no batching. Must be greater than 1 if specified.\n * @returns {number[][]} The resulting matrix (N x K).\n * @throws {Error} If the inner dimensions of the matrices do not match.\n * @throws {Error} If the batch size is less than 2.\n */\nexport async function matrixMultiply(matrix1, matrix2, batchSize=1024) {\n  const N = matrix1.length;\n  const M = matrix1[0].length;\n  const M2 = matrix2.length;\n  const K = matrix2[0].length;\n\n  if (M !== M2) {\n    throw new Error(\"Inner dimensions of matrices must match for multiplication\");\n  }\n\n  if (batchSize == null) {\n    batchSize = Math.max(N, M, K)\n  }\n\n  if (batchSize < 2) {\n    throw new Error(\"Batch size must be >1\");\n  }\n\n  // Initialize the result matrix with zeros.\n  const result = Array.from({ length: N }, () => Array(K).fill(0));\n\n  const numRowBlocks1 = Math.ceil(N / batchSize);\n  const numColBlocks1 = Math.ceil(M / batchSize);\n  const numColBlocks2 = Math.ceil(K / batchSize);\n\n  for (let i = 0; i < numRowBlocks1; i++) {\n    for (let j = 0; j < numColBlocks2; j++) {\n      for (let k = 0; k < numColBlocks1; k++) {\n        \n        // Calculate block indices (start and end rows/cols)\n        const rowStart1 = i * batchSize;\n        const rowEnd1 = Math.min((i + 1) * batchSize, N);\n        const colStart1 = k * batchSize;\n        const colEnd1 = Math.min((k + 1) * batchSize, M);\n\n        const rowStart2 = k * batchSize;\n        const rowEnd2 = Math.min((k + 1) * batchSize, M);\n        const colStart2 = j * batchSize;\n        const colEnd2 = Math.min((j + 1) * batchSize, K);\n\n          \n        // Multiply and accumulate\n        const product =  await _matrixMultiplySlice(matrix1, matrix2, \n          [[rowStart1, rowEnd1],[colStart1, colEnd1]],[[rowStart2, rowEnd2],[colStart2, colEnd2]]);\n\n        for (let pRow = 0; pRow < product.length; pRow++) {\n          for (let pCol = 0; pCol < product[0].length; pCol++) {\n            result[rowStart1 + pRow][colStart2 + pCol] += product[pRow][pCol];\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nasync function _matrixMultiplySlice(A, B, aSlice, bSlice) {\n const slicedARows = aSlice[0][1] - aSlice[0][0];\n const slicedACols = aSlice[1][1] - aSlice[1][0];\n const slicedBRows = bSlice[0][1] - bSlice[0][0];\n const slicedBCols = bSlice[1][1] - bSlice[1][0];\n\n // Check WebGPU availability\n if (!(\"gpu\" in navigator)) {\n   console.error(\"WebGPU not supported. Falling back to CPU multiplication.\");\n   return _cpuMatrixMultiply(A, B, aSlice, bSlice);\n }\n\n // Try GPU multiplication in a try/catch\n try {\n   const adapter = await navigator.gpu.requestAdapter();\n   const device = await adapter.requestDevice();\n\n   // Flatten A, using the slice\n   const Adata = new Float32Array(slicedARows * slicedACols);\n   let idx = 0;\n   for (let i = aSlice[0][0]; i < aSlice[0][1]; i++) {\n     for (let j = aSlice[1][0]; j < aSlice[1][1]; j++) {\n       Adata[idx++] = A[i][j];\n     }\n   }\n\n   // Flatten B, using the slice\n   const Bdata = new Float32Array(slicedBRows * slicedBCols);\n   idx = 0;\n   for (let i = bSlice[0][0]; i < bSlice[0][1]; i++) {\n     for (let j = bSlice[1][0]; j < bSlice[1][1]; j++) {\n       Bdata[idx++] = B[i][j];\n     }\n   }\n\n   // Prepare buffers\n   const bufferA = device.createBuffer({\n     size: Adata.byteLength,\n     usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n   });\n   const bufferB = device.createBuffer({\n     size: Bdata.byteLength,\n     usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n   });\n\n   const cRows = slicedARows;\n   const cCols = slicedBCols;\n   const cSizeBytes = 4 * cRows * cCols;\n\n   const bufferC = device.createBuffer({\n     size: cSizeBytes,\n     usage:\n       GPUBufferUsage.STORAGE |\n       GPUBufferUsage.COPY_SRC |\n       GPUBufferUsage.COPY_DST\n   });\n\n   // Uniform buffer {slicedARows, slicedACols, slicedBCols, 0}\n   const uniformBuffer = device.createBuffer({\n     size: 16, // 4 x 4 bytes\n     usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n   });\n\n   // Upload data\n   device.queue.writeBuffer(bufferA, 0, Adata);\n   device.queue.writeBuffer(bufferB, 0, Bdata);\n   const dims = new Uint32Array([slicedARows, slicedACols, slicedBCols, 0]);\n   device.queue.writeBuffer(uniformBuffer, 0, dims);\n\n   // WGSL shader\n   const shaderCode = /* wgsl */ `\n       @group(0) @binding(0) var<storage, read> A : array<f32>;\n       @group(0) @binding(1) var<storage, read> B : array<f32>;\n       @group(0) @binding(2) var<storage, read_write> C : array<f32>;\n       @group(0) @binding(3) var<uniform> dims : vec4<u32>;\n       // dims.x = slicedARows, dims.y = slicedACols, dims.z = slicedBCols\n\n       @compute @workgroup_size(16, 16)\n       fn main(@builtin(global_invocation_id) gid : vec3<u32>) {\n         let aRows = dims.x;\n         let aCols = dims.y;\n         let bCols = dims.z;\n\n         let row = gid.y;\n         let col = gid.x;\n\n         if (row < aRows && col < bCols) {\n           var sum = 0.0;\n           for (var k = 0u; k < aCols; k++) {\n             sum += A[row * aCols + k] * B[k * bCols + col];\n           }\n           C[row * bCols + col] = sum;\n         }\n       }\n     `;\n   const shaderModule = device.createShaderModule({ code: shaderCode });\n\n   // Pipeline\n   const pipeline = device.createComputePipeline({\n     layout: \"auto\",\n     compute: {\n       module: shaderModule,\n       entryPoint: \"main\"\n     }\n   });\n\n   // Bind group\n   const bindGroup = device.createBindGroup({\n     layout: pipeline.getBindGroupLayout(0),\n     entries: [\n       { binding: 0, resource: { buffer: bufferA } },\n       { binding: 1, resource: { buffer: bufferB } },\n       { binding: 2, resource: { buffer: bufferC } },\n       { binding: 3, resource: { buffer: uniformBuffer } }\n     ]\n   });\n\n   // Encode commands\n   const commandEncoder = device.createCommandEncoder();\n   const passEncoder = commandEncoder.beginComputePass();\n   passEncoder.setPipeline(pipeline);\n   passEncoder.setBindGroup(0, bindGroup);\n\n   // Dispatch\n   const workgroupSize = 16;\n   const dispatchX = Math.ceil(cCols / workgroupSize);\n   const dispatchY = Math.ceil(cRows / workgroupSize);\n   passEncoder.dispatchWorkgroups(dispatchX, dispatchY);\n   passEncoder.end();\n\n   // Copy back to a CPU-readable buffer\n   const readBuffer = device.createBuffer({\n     size: cSizeBytes,\n     usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n   });\n   commandEncoder.copyBufferToBuffer(bufferC, 0, readBuffer, 0, cSizeBytes);\n\n   // Submit\n   device.queue.submit([commandEncoder.finish()]);\n   await readBuffer.mapAsync(GPUMapMode.READ);\n   const arrBuffer = readBuffer.getMappedRange();\n   const result = new Float32Array(arrBuffer.slice(0));\n   readBuffer.unmap();\n\n   // Convert to 2D\n   const C = [];\n   let pos = 0;\n   for (let i = 0; i < cRows; i++) {\n     const rowData = [];\n     for (let j = 0; j < cCols; j++) {\n       rowData.push(result[pos++]);\n     }\n     C.push(rowData);\n   }\n\n   return C;\n } catch (err) {\n   console.error(\"WebGPU error:\", err, \"Falling back to CPU multiplication.\");\n   // If anything fails on GPU side, fallback:\n   return _cpuMatrixMultiply(A, B, aSlice, bSlice);\n }\n}\n\nfunction _cpuMatrixMultiply(A, B, aSlice, bSlice) {\n  const [aRowStart, aRowEnd] = aSlice[0];\n  const [aColStart, aColEnd] = aSlice[1];\n  const [bRowStart, _] = bSlice[0];\n  const [bColStart, bColEnd] = bSlice[1];\n\n  const aCols = aColEnd - aColStart;\n\n  const resultRows = aRowEnd - aRowStart;\n  const resultCols = bColEnd - bColStart;\n  const C = Array(resultRows).fill(null).map(() => Array(resultCols).fill(0));\n\n  for (let i = 0; i < resultRows; i++) {\n    for (let j = 0; j < resultCols; j++) {\n      for (let k = 0; k < aCols; k++) {\n        C[i][j] += A[aRowStart + i][aColStart + k] * B[bRowStart + k][bColStart + j];\n      }\n    }\n  }\n\n  return C;\n}"],"names":["async","_matrixMultiplySlice","A","B","aSlice","bSlice","slicedARows","slicedACols","slicedBRows","slicedBCols","navigator","console","error","_cpuMatrixMultiply","adapter","gpu","requestAdapter","device","requestDevice","Adata","Float32Array","idx","i","j","Bdata","bufferA","createBuffer","size","byteLength","usage","GPUBufferUsage","STORAGE","COPY_DST","bufferB","cRows","cCols","cSizeBytes","bufferC","COPY_SRC","uniformBuffer","UNIFORM","queue","writeBuffer","dims","Uint32Array","shaderCode","shaderModule","createShaderModule","code","pipeline","createComputePipeline","layout","compute","module","entryPoint","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","workgroupSize","dispatchX","Math","ceil","dispatchY","dispatchWorkgroups","end","readBuffer","MAP_READ","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","arrBuffer","getMappedRange","result","slice","unmap","C","pos","rowData","push","err","aRowStart","aRowEnd","aColStart","aColEnd","bRowStart","_","bColStart","bColEnd","aCols","resultRows","resultCols","Array","fill","map","k","matrix1","matrix2","batchSize","N","length","M","M2","K","Error","max","from","numRowBlocks1","numColBlocks1","numColBlocks2","rowStart1","rowEnd1","min","colStart1","colEnd1","rowStart2","rowEnd2","colStart2","colEnd2","product","pRow","pCol"],"mappings":"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"}